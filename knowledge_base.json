{
  "2 MBR.pdf": "\n\n=== Page 1 ===\n\nMBR and GPT Analysis  \n- Introduction  \nImagine your disk as a large building storing all the data. This data is stored in \nbinary format, as 1s and 0s, for the computers to understand. The challenge here is \nthat without properly organizing this data, it would be a mess in the whole disk. \nTo solv e this problem, the disk is divided into multiple partitions, just like rooms \nin the building, and each partition contains specific data.   For example, operating \nsystem files can be stored in one partition, personal files can be stored in another, \netc. In the Windows OS, these partitions are represented by drive letters such \nas C, D, E, etc. Other operating systems may use different ways to refer to these \npartitions.   \n \n \n \n- Boot Process :  \nThe boot process wakes up the whole system. It starts by initializing the \nsystem's hardware components, loading the operating system into \nmemory, and finally allowing the user to interact with the system.  In this \ntask, we will cover the start of the boot p rocess before the role of the \nMBR/GPT. The aim is to understand the basic booting of a system before \n\n\n=== Page 2 ===\n\nwe dive into the structure of the MBR/GPT and explore their forensic \nvalue.  \nThe overall boot process of a system has multiple steps, as can be seen in \nthe flow diagram below:   \n \n\n\n=== Page 3 ===\n\nPower -On the System  \nThe first step of the boot process starts with pushing the power button, \nwhich sends electrical signals to the motherboard and initializes all the \ncomponents. The CPU is the first component to get the electrical signals \nand needs some instructions to move further. The CPU fetches and \nexecutes these instructions from a chipset deployed on the \nmotherboard. This chipset is known as BIOS/UEFI, and it contains \ninstructions on how to get the boot process going.  \n \nBIOS  (Basic Input/Output System) and UEFI  (Unified Extensible Firmware \nInterface) are responsible for verifying whether all the hardware \ncomponents work properly. A system can either use BIOS or UEFI \nfirmware. The difference between them lies in their capabilities and \nfeatures.  \n• BIOS has been used for decades and is still used in some \nhardware. It runs in the basic 16 -bit mode and supports only up to \n2 terabytes of disks. The most important thing to note is that BIOS \nsupports the MBR partitioning scheme, which we will discuss later \nin the task.  \n• UEFI came as a replacement for BIOS, offering 32 -bit and 64 -bit \nmodes with up to 9 zettabytes of disks. UEFI offers a secure boot \nfeature to ensure integrity during the system boot process. It also \noffers redundancy, allowing us to recover from the backup even if \nthe boot code is corrupted. UEFI uses a GPT partitioning scheme, \nunlike the MBR partitioning scheme used by BIOS.  \n\n\n=== Page 4 ===\n\nThere are several ways to check if your system uses BIOS or UEFI \nfirmware. The process can be different depending on the operating \nsystem you use. For the Windows OS,   first open the Run dialog box by \npressing Windows+R . Type msinfo32 in this dialog box a nd press enter. \nThis will show you the system summary. If it is running BIOS, the field \nnamed BIOS Mode  would be shown as the Legacy . Otherwise, it would \nbe UEFI . \n \n \n \nPower -On-Self-Test (POST)  \nThe system is now powered on, and the CPU has executed instructions \nfrom the firmware (BIOS/UEFI) installed. The BIOS/UEFI then starts a \nPower -On-Self-Test to ensure all the system’s hardware components are \nworking fine. You may hear a single or multiple b eeps during this process \nin your system; this is how the BIOS/UEFI communicates any errors in the \nhardware components and displays the error message on the screen, \ne.g., keyboard not found.  \n\n\n=== Page 5 ===\n\n \nLocate the Bootable Device  \nAfter the BIOS/UEFI has performed the POST check, it is time for the \nBIOS/UEFI to locate bootable devices, such as SSDs, HDDs, or USBs, with \nthe operating system installed.  Once the bootable device is located, it \nstarts reading this device. Now, here comes  the role of the  MBR/GPT . \nThe very first sector of the device would either contain the MBR (Master \nBoot Record) or the GPT (GUID Partition Table). The MBR/GPT would be \ntaking control of the boot process from here.  In the upcoming tasks, we \nwill see how the  boot process propagates from here if the MBR \npartitioning scheme is used and what happens if it is GPT instead.  \n \n\n\n=== Page 6 ===\n\n \n- Analyzing the MBR  \n \nIn the previous task, we learned about the boot process, from when the \ncomputer powers on till the bootable device is located. In this task, we \nwill assume that the bootable device found uses the MBR partitioning \nscheme. MBR has been used for decades and i s now replaced by the GPT \nin modern systems. However, it is important to learn the MBR as it is still \nused in some systems.  \nThe bootable device, which was located in the 3rd step of the boot \nprocess, would be in the form of a disk. A disk is divided into multiple \nsectors, each with a standard size of 512 bytes. The first sector of this \ndisk would contain the MBR.   A disk's MBR can be viewed by taking the \nsystem's disk image and opening it in a hexadecimal editor.  \nWe will be using the HxD tool, a hexadecimal editor available in the \ntaskbar of the attached machine. Open the HxD tool, click the File button \nin the options tab, and select Open from the options. Now, you have to \ninput the file's location to be opened. We  have extracted the MBR \nportion from a disk image and saved it at C: \\Analysis \\MBR. You can \nselect this file to examine the MBR for this task.  \n \n\n\n=== Page 7 ===\n\nThis will open it in hexadecimal format. It is to be noted that the MBR \nprovided to you in the attached machine is different from the one \npresented in the screenshots.  \n \n  \nThe Master Boot Record (MBR) takes up 512 bytes of space at the very \nfirst sector of the disk. Now, we know that it starts from the very first \nsector. We can easily analyze the MBR code by starting from the first line, \nbut how do we know where this MBR cod e ends? The answer to this \nquestion is straightforward. Every two digits coupled in hexadecimal \nrepresents 1 byte, and once the first 512 bytes of the disk completes, the \nMBR has been ended. So, in the hexadecimal editor we are using, 16 \nbytes are present in each row, meaning that the first 32 rows of the disk \nwould be the whole MBR. Another way to spot the end is by looking at \nthe MBR signature. The MBR signature is represented by  55 AA, which \nmarks the end of the MBR code. You can look for these hexadecim al \ndigits to  identify where the MBR ends.  \n\n\n=== Page 8 ===\n\nThe screenshot below shows the MBR portion (first 512 bytes) of a disk \nwhen opened into the hex editor. You can see that these are the first 32 \nrows (16 bytes for each row) and ending at 55 AA (MBR Signature).  The \nfirst highlighted portion represents the b ytes offset, the second \nrepresents the actual hexadecimal bytes, and the third represents the \nASCII -converted text of the hexadecimal bytes. We would focus on the \nsecond portion, the hexadecimal bytes. In this task, we will analyze this \nwhole MBR by decodi ng the meaning of these hexadecimal digits.   \n  \n \nBefore we start analyzing the bytes, it's important to understand that \ntogether, every two hexadecimal digits present a single byte.  These 512 \nbytes of the MBR are further divided into three portions.  The following \nscreenshot highlights each of the three p ortions of the MBR with \ndifferent colors.  \n\n\n=== Page 9 ===\n\n \nThe structure of the MBR can be seen below:  \n \n\n\n=== Page 10 ===\n\n  \nLet's dissect each of the three portions of the MBR.  \nBootloader Code (Bytes 0 -445)  \nThe first component of the MBR is the Bootloader code. They cover 446 \nout of the total 512 bytes of the MBR, as shown in the screenshot \nbelow:   \n \nThis Bootloader code contains the Initial Bootloader . The initial \nbootloader is the first thing that executes in the MBR. This initial \nbootloader code has a primary purpose of finding the bootable \npartition  from the  partition table  present on the MBR.   \nNote:  To better understand the initial bootloader code, it can be \ndisassembled into assembly language, which is beyond the scope of this \ntask.  \nPartitions Table (Bytes 446 -509)  \nThe second component of the MBR is the partition table, which \ncomprises 64 bytes (Bytes 446 -509). This table contains the details of all \nthe partitions present on the disk. One of the partitions in the disk \n\n\n=== Page 11 ===\n\ncontains all the operating system files necessary for booting, known as a \nbootable partition.  The initial bootloader that was started from the \nbootloader code of the MBR   finds the bootable partition from this \npartition table, and it loads the second bootl oader from it. The second \nbootloader then loads the  Operating System's Kernel . A partition table is \nused during this boot process. However, this partition table can also give \nus valuable information during forensics. Let's dive into the details of this \npartition table.  \nAn MBR disk has a total of 4 partitions, and each partition is represented \nby 16 bytes in the partition table.  In the screenshot below, four \npartitions (each with 16 bytes) are highlighted with different colors.   \n \nNow, for your understanding, we have also shown the partition details of \nthe same disk through the disk management utility of the Windows OS. \nThe same four partitions can be seen here:  \n \n \nUnlike the bootloader code, the hexadecimal digits of these partitions \nthemselves can tell you many things.  Let's use the first partition from the \npartition table screenshot as a reference to analyze the meaning of all \nthe hexadecimal digits.  \n\n\n=== Page 12 ===\n\nThe screenshot below shows the first partition from the partition table of \nthe MBR. All the bytes have some specific meaning. Some bytes \nindividually represent a field, while others are grouped together to form \na field. We have highlighted all these differ ent byte groups with different \ncolors.   \n \nThe table below shows the fields represented by these bytes.   \nBytes Position  Bytes Length  Bytes  Field Name  \n0 1 80 Boot Indicator  \n1-3 3 20 21 00  Starting CHS Address  \n4 1 07 Partition Type  \n5-7 3 FE FF FF  Ending CHS Address  \n8-11 4 00 08 00 00  Starting LBA Address  \n12-15 4 00 B0 23 03  Number of Sectors  \nEach field tells you something about the partition. Below is an \nexplanation of all these fields:  \n1. Boot Indicator:  This byte tells you whether the partition is \nbootable or not. A bootable partition contains files necessary for \nthe operating system to boot. This boot indicator can only have \none of the two values: 80 or 00. If it's 80, it means that the \npartition is boo table; else, if it's 00, it means that the partition is \nnot bootable.   In Windows based systems,  C: is the partition that is \ntypically bootable. If visualized through the partition table, this \npartition would have the boot indicator set to 8 0. \n2. Starting CHS Address: Cylinder Head Sector (CHS) is the 3 bytes \nthat tell you where this partition is starting from on the disk. It will \ngive you the starting physical address of the partition, such as the \ncylinder, head, and sector number. This field is not that important \nas w e now have the simplified logical address of the partition in \nthe form of the Starting LBA Address discussed ahead.  \n\n\n=== Page 13 ===\n\n3. Partition Type: Every  partition uses a filesystem such as NTFS, \nFAT32, etc. This byte indicates the filesystem of the partition. The \npartition we are taking as a reference has this byte as 07, which \nmeans it is an NTFS partition. Every filesystem has its own unique \nbyte. You can learn about the bytes used for other filesystems \nfrom here . \n4. Ending CHS Address: The last 3 bytes at the end of the CHS \nAddress indicates the physical location where the partition ends \non the disk.  This field is also not that important, just like the stated \nCHS address, as we mostly use the logical address (LBA) instead of \nthe physical  address.  \n5. Starting LBA Address: Logical Block Addressing (LBA) is the logical \naddress that indicates the start of the partition. We saw that the \nStarting CHS Address also gives us the starting address of the \npartition, but because CHS gives you the physical address of the \npartition, it b ecomes difficult for us to locate it. However, the \nStarting LBA Address gives you the logical address of the partition \nrather than the physical address. You can use it to easily find the \nstart of the partition on the disk in a hexadec imal editor. By \nlocating the partition on the disk, you can also carve data from a \ndisk's hidden or deleted partitions. Based on the partition we are \nanalyzing as a reference with 00 08 00 00 LBA, we will use this \nlogical address to locate our partition la ter in this task.  \n6. Number of Sectors: These last 4 bytes of a partition tell you the \nnumber of sectors in the partition. We will calculate the sector's \nsize by using this field ahead.  \nFrom the information above, the boot indicator and the partition type \nbytes are pretty straightforward and do not need any more explanation. \nThe starting and ending CHS addresses are physical addresses and do not \nhold much importance. However, let's see ho w we can use the Starting \nLBA Address  to locate a partition and the Number of Sectors  to calculate \nthe size of the partition.  \nLocating the Partition  \nThe starting LBA address bytes of the partition we are using as a \nreference in this task is  00 08 00 00. These bytes are stored in the little -\n\n=== Page 14 ===\n\nendian format in which the Least Significant Byte (LSB) is first, and the \nMost Significant Byte (MSB) is last. So, we must first reverse these \nbytes.  Reversing these bytes would make it 00 00 08 00.   \nThe next step is to convert these into decimal format. You can either use \nan online tool for this or view the decimal converted value of these bytes \nwithin the HxD hex editor tool. Select the bytes for which you need the \ndecimal value, and it will be displ ayed in the Int32 option of the Data \nInspector pane on the right side.  \n \nNow that we have the decimal value as 2048, we have to multiply it by \nthe size of the sector, which is 512 bytes.   \n2048 x 512 = 1,048,576  \n1,048,576 is the exact value where the partition is stored. The last step is \nto search for this value in the HxD tool to jump to the start of this \npartition. To search this value, first click the Search  button and then click \nthe Go to option.  \n\n\n=== Page 15 ===\n\n \nNow, input the value in the prompt, select the decimal format (dec) and \nclick the OK button.  \n \nThis will take you to the start of this partition on the disk. This can help \nyou in carrying out detailed forensics of a specific partition. You can also \nrecover any hidden or deleted data from here that has not yet been \noverwritten.  As the file provided t o you in this task is just comprised of \nthe MBR and not the whole disk, you would not be able to jump to the \nstarting LBA of the partition, which is in a separate place from the MBR.  \nNote: Please remember this method of reversing the LBA address (little \nendian), converting it to decimal, multiplying it with the sector size (512 \nbytes), and finally searching it into the hex editor to jump to the exact \n\n\n=== Page 16 ===\n\nlocation. You will encounter some other Logical Block Addresses (LBA) in \nthe GPT structure.  \nCalculating the Size of Partition  \nThe last four partition bytes represent the Number of Sectors field. As \nper our partition, these bytes are  00 B0 23 03 and if we reverse it as they \nare in little -endian, they become 03 23 B0 00. The next step is to convert \nthem to decimal. You can find the  decimal value within the HxD tool by \nhighlighting the bytes just as we did for the starting LBA address while \nlocating the partition. The decimal value comes out to be  52,670,464. \nNow, as we know, each sector's size is 512 bytes. We can multiply them \nto get the size of this partition in bytes.  \n52,670,464 x 512 = 26,967,277,568 bytes  \nMBR Signature (Bytes 510 -511)  \nThe last part of the MBR is the MBR Signature. It is just two bytes, which \nis short, but if messed up, it can cause huge trouble. The screenshot \nbelow shows the whole MBR with the MBR signature highlighted at the \nvery bottom.  \n \n \n\n\n=== Page 17 ===\n\nThese two bytes 55 AA are also known as a Magic Number  and they \nindicate that the MBR has been ended now. If these two bytes are \nchanged to some value other than 55 AA, the system cannot boot. These \nbytes often get corrupted due to bad sectors on the disk and sometimes \ncan be intentionally changed by malware to interrupt the normal boot \nprocess.  \nTo sum up the whole boot process of the MBR:  \n1. The initial bootloader starts from the bootloader code (the first \ncomponent of the MBR).  \n2. It then finds the bootable partition from the partition table (the \nsecond component of the MBR).  \n3. Then it loads the second bootloader from this bootable partition.  \n4. Finally, with this, the OS kernel gets loaded, and after this process, \nthe drivers, services, and filesystems are loaded into the memory, \nand the user is given control of the OS interface. This is a system's \nwhole boot process using an MBR partitioned disk . \nAnswer the questions below  \nWhich component of the MBR contains the details of all the partitions \npresent on the disk?  \n- partition table  \nWhat is the standard sector size of a disk in bytes?  \n- 512 \nWhich component of the MBR is responsible for finding the bootable \npartition?  \n- bootloader code  \nWhat is the magic number inside the MBR?  \n- 55 AA  \nWhat is the maximum number of partitions MBR can support?  \n- 4 \n\n=== Page 18 ===\n\nWhat is the size of the second partition in the MBR file found in \nC:\\Analysis \\MBR \\? (rounded to the nearest GB)  \n- 16 \n \n \n- Example of Bootkit  \n \nMBR is not that common nowadays and is replaced by GPT. This \nhappened when the UEFI firmware (compatible with GPT), which is more \nefficient and redundant, replaced BIOS (compatible with MBR). However, \nas the MBR is still being used in some disks, it is imp ortant to understand \nthe threat surface of the MBR.  \nAs the MBR plays a crucial role in booting the operating system, it \nbecomes an attractive target for attackers. The total 512 bytes of the \nMBR hold extreme importance for the whole system. Anybody who can \nplay with these 512 bytes can hijack the whole syst em. Several types of \nmalware are designed to target the MBR.   Let's explore some common \nmalware leveraging the MBR to achieve their objective.  \n• Bootkits:  \nBootkits are a very dangerous type of malware. Since the MBR executes \nbefore the OS starts, the bootkits  craft themselves into the MBR \nto bypass the OS's protection mechanisms. Even complete malware \nremoval or reinstallation of the OS cannot remove the boo tkits as they \nreside in the MBR.  \n \n\n\n=== Page 19 ===\n\n• Ransomware:  \nMBR is the first thing executed on the disk during the boot process, and \nthe boot process heavily relies on it. Instead of encrypting the individual \nfiles of the system, attackers encrypt and modify the MBR to interrupt \nthe boot process and display their r ansom notes on the screen. Petya \nransomware, detected in 2016, encrypts the MBR rather than all the disk \nfiles. Another example is the Bad Rabbit ransomware, which overwrites \nthe original MBR with its malicious bootloader code and displays a \nransom note on  the screen upon reboot of the system.  \n \n• Wiper Malware:  \nThis type of malware intends to corrupt the MBR to make the system \nunbootable. Any change in the original MBR of a disk can make the \nsystem completely unbootable. The Shamoon malware is one such \nmalware that overwrites the MBR with random characters to mak e the \nsystem unbootable. In the next task, we will examine a similar case in \nwhich malware corrupted the MBR of a disk to make the system \nunbootable.  \n \n  \n\n\n=== Page 20 ===\n\n \n- MBR Tampering Case  \n \nScenario  \nAn organization's critical database server suddenly became unbootable, \ncausing widespread panic. The initial investigation found an employee \nopened a malicious email attachment, prompting a reboot. The \nemployee rebooted the system, after which the system b ecame \ncompletely unbootable. Most of the clues point to the malware's \ndeliberate corruption of the server's Master Boot Record (MBR).  \nA quick look at the server's MBR points to two corruptions. One of them \nis the logical address of the first partition, which was previously  00 08 00 \n00, and the other is a critical component of the MBR that must be the \nsame across all the MBRs. Fixing thes e corrupted bytes will make the \nsystem bootable again, which can be verified by re -opening the fixed disk \nimage using FTK Imager.  \nInstructions  \nIn this task, you will utilize two tools, FTK Imager and HxD. Both tools are \navailable in the taskbar and Desktop of the machine.  \nHxD   \nHxD is a hexadecimal editor. You can view the MBR contents of a disk by \nopening it into the hexadecimal editor, just as we did in task #3. In this \ntask, you will use HxD to examine the corrupted hexadecimal bytes of \nthe MBR and fix these bytes by following th e clues in the scenario. The \ndisk under examination is placed at \nC:\\Analysis \\MBR_Corrupted_Disk.001. Open this disk image using the \nHxD tool.   Now, to fix the corrupted bytes, you can click on the corrupted \nbyte and type the new correct one. Once you are d one with replacing all \nthe corrupted bytes, save the disk image using the Save button located in \nthe dropdown of the File option, as shown in a sample screenshot \nbelow:  \n\n=== Page 21 ===\n\n \nNote: You may encounter an error message that says:  \"There is not \nenough space on the disk.\"  while saving the changes. This is because \nHxD creates a backup of the original file before saving the changes, and \ndue to insufficient space, it cannot make a backup. However, it does not \nstop you from saving the file. It gives you the option to save \nanyw ay. Click Yes to proceed, and the file will be saved without the \nbackup creation.  \nNow, as the corrupted bytes are fixed and saved into the disk image, \nopen the fixed disk image using FTK Imager (guideline given ahead) and \nverify that you can see all the contents of the disk. If the disk contents \nare properly available, the corrupted MBR  is recovered, and the disk is \nready to boot again.  \nFTK Imager   \nFTK Imager is a forensics tool that you can use to create or examine a \ndisk image's contents.  The infected disk image was preserved \nimmediately after the attack by booting the system with a live USB.  You \nare provided with this disk image and you can use FT K Imager to test and \nexamine its content. Initially, before you deploy the fix, this disk image, \nwhen opened with FTK Imager, will show the error \"Unrecognized file \nsystem.\" However, once the disk's MBR is fixed, you will be able to \nexamine the contents of  the whole disk in the FTK Imager.  \n\n\n=== Page 22 ===\n\nTo open a disk image using FTK Imager, you need the following steps:  \nClick on the File button available in the options tab and then choose Add \nEvidence Item.  \n  \nNow, select the Image File option and click the Next button.  \n \nLastly, enter the source path of the image file and click the Finish button \nto view the contents of the disk image.  \n\n\n=== Page 23 ===\n\n \nThe left pane would display the disk image in a tree format. You can \nexpand the contents of the disk by clicking the + icon. Currently, it \ndisplays Unrecognized file system as the disk's MBR is corrupted. The \nright pane will give you the contents and detai ls of the files and folders \nyou select inside the left pane.  \n \nAnswer the questions below  \nHow many partitions are on the disk?  \n\n\n=== Page 24 ===\n\n1 \nWhat is the type of the partition?  \nNTFS  \nWhat is the size of the partition? (rounded to the nearest GB)  \n32 \n ",
  "3 GPT.pdf": "\n\n=== Page 1 ===\n\nGPT Partition  \n \n- What if GPT?  \n \nPreviously, we studied how the boot process propagates with the MBR. \nIn this task, we will explore what the boot process looks like when a \nmodern GPT partitioning scheme is used in the disk instead of the MBR.  \nUEFI firmware with the GPT partitioning scheme replaced BIOS firmware \nwith the MBR partitioning scheme. This replacement occurred due to \nsome limitations in the BIOS and the MBR. The GPT supports up to 9 \nzettabytes of hard disks, unlike the MBR, which supp orts a maximum of 2 \nterabytes. The GPT also supports up to 128 partitions, unlike the MBR, \nwhich only supports 4. There are some other differences between both \nof the partitioning schemes.    \nGPT is now a preferred partitioning scheme in most modern systems. It is \ncompatible with systems that have UEFI firmware. Let's take a look at the \nstructure of the GPT.  \nWe previously saw that the MBR only occupies the disk's first sector (512 \nbytes). However, this is not the case with the GPT. The GPT has five \ncomponents spread across multiple sectors of the disk. Let's start \ndissecting each component of the GPT.  \nNote:  We have extracted the first two components of the GPT in hex \nformat and saved them at C: \\Analysis \\GPT. You can use this file in HxD to \nexamine the GPT in this task.  It is to be noted that the GPT provided to \nyou in the attached machine is different from t he one presented in the \nscreenshots.  \n \n\n=== Page 2 ===\n\n \n \n \nProtective MBR  \nIdeally, if the disk is GPT partitioned, the system should have UEFI \nfirmware to handle it.   However, some legacy systems still use BIOS \nfirmware even though the disk is GPT partitioned. This can be a problem \nas the BIOS firmware is designed to work with t he MBR and UEFI \nfirmware is designed to work with the GPT. To solve this problem, the \nGPT has Protective MBR. The Protective MBR is in the disk's first sector, \npartitioned with the GPT. The purpose of the Protective MBR   is to signal \nthe BIOS system that t his disk is using the GPT, so please don't mess up \nwith it thinking that it is the MBR.  \nThe Protective MBR also has three components, just like the general \nMBR, but with a few differences. Below is a screenshot of the Protective \nMBR found in the GPT, with its three components highlighted with \ndifferent colors.  \n\n\n=== Page 3 ===\n\n \nThe details of these components are given below:  \n1. Bootloader Code: This bootloader code is not the same as it is in \nthe general MBR. This bootloader code does not perform any \nfunction during the boot process. It is just there to look like it's the \nsame standard MBR bootloader. This would be all 00s in most \nscenarios; howe ver, sometimes, this can contain some placeholder \ncode for legacy compatibility.  \n2. Partition Table: This partition table contains only one partition \n(the first 16 bytes), and this partition has one job; to redirect the \nsystem to the EFI Partition (which we will discuss later). The \nscreenshot of the protective MBR above shows that it only has \none partitio n in the table, and the other partitions are labeled \nwith 0s. In this single partition, there is only one important thing: \nthe 4th byte. This byte is set to EE, indicating that this is a GPT -\nformatted disk.   \n \n\n\n=== Page 4 ===\n\n3. MBR Signature: The MBR signature is the same as in the standard \nMBR. It is set to 55 AA  and marks the end of the Protective MBR.  \nPrimary GPT Header  \nThe GPT header starts right from the next byte (the start of sector 1) \nafter the Protective MBR ends at 55 AA (the end of sector 0). It acts as a \nblueprint of the partitions on the disk. All the bytes in the GPT header \nhave a specific meaning. Below is a s creenshot of the GPT header with \nthese bytes highlighted with different colors. It has the whole 512 sector \nspace but occupies the first 92 bytes of space, and after these 92 bytes, \nthere would be all 00 bytes for padding purposes to complete the \nsector's total bytes. So, for the Primary GPT header, you only need to \nfocus on the first 92 bytes, which can give you some meaningful \ninformation.  \n \nThe table below shows the position of these bytes and their field names.  \nBytes \nPosition  Bytes \nLength  Bytes  Field Name  \n0-7 8 45 46 49 20 50 41 52 54  Signature  \n8-11 4 00 00 01 00  Revision  \n12-15 4 5C 00 00 00  Header Size  \n16-19 4 71 89 13 1C  CRC32 of Header  \n20-23 4 00 00 00 00  Reserved  \n24-31 8 01 00 00 00 00 00 00 00  Current LBA  \n32-39 8 AF 32 CF 1D 00 00 00 00  Backup LBA  \n40-47 8 22 00 00 00 00 00 00 00  First Usable LBA  \n48-55 8 8E 32 CF 1D 00 00 00 00  Last Usable LBA  \n\n\n=== Page 5 ===\n\nBytes \nPosition  Bytes \nLength  Bytes  Field Name  \n56-71 16 1D F1 B0 D6 43 BE 37 4E B1 \nE6 38 66 EC B1 73 89  Disk GUID  \n72-79 8 02 00 00 00 00 00 00 00  Partition Entry \nArray LBA  \n80-83 4 80 00 00 00  Number of \nPartition Entries  \n84-87 4 80 00 00 00  Size of Each \nPartition Entry  \n88-91 4 41 0D C0 22  CRC32 of Partition \nArray  \nEach of these 14 fields has a specific purpose and meaning. Below is an \nexplanation of all these fields.  Before starting with the explanation of \nthese fields, it is important to note that some of the fields represent \nLogical Block Addresses (LBA). To calcu late the exact address through \nthese LBAs, you must follow the same steps we performed while locating \nthe partition in the MBR task. These steps included reversing the bytes \nstored in a little -endian format, then converting them to decimals and \nsearching t hem on the HxD tool to jump to the exact LBA location.  \n1. Signature: This field has a value  45 46 49 20 50 41 52 54 which \nrecognizes it as a GPT header. This value is always at the start of \nthe GPT header.  \n2. Revision: The revision number is of 4 bytes and it represents the \nversion of the GPT. Most of the times it would be  00 00 01 00 \nwhich means the GPT version is 1.0.  \n3. Header Size: This field represents the size of the GPT header. It is \ntypically 5C 00 00 00 in hex and if you convert it to decimal (after \nreversing the order of bytes as they are in little -endian), it is 92 \nbytes which is the length of the GPT header.  \n\n=== Page 6 ===\n\n4. CRC32 of Header: This is the CRC32 checksum of the GPT header, \nwhich if changed, would indicate that either the GPT header is \ntampered or corrupted.  \n5. Reserved: These are reserved bytes. The purpose of having them \nis to utilize them for any future changes in the GPT header.  \n6. Current LBA: The Current Logical Block Address (LBA) indicates the \nlocation of the GPT header. We know that its location is in sector \n1, and we can verify this by converting the 8 Current LBA bytes 01 \n00 00 00 00 00 00 00 into decimal.  \n7. Backup LBA: In the GPT partitioning scheme, we have a backup of \nthe GPT header as well, which we will be studying later on in this \ntask. This field indicates the LBA of the backup GPT header.  \n8. First Usable LBA: This LBA address indicates the first address from \nwhich the partition can start on the disk.  \n9. Last Usable LBA: This LBA address indicates the last address to \nwhich the partitions on the disk can be written. Any partitions \ncannot occupy the disk space after the last usable LBA.  \n10. Disk GUID: This field is of 16 bytes and it presents a Globally \nUnique Identifier of the disk. The purpose of this GUID is to \ndistinguish the disk from any other disks present in the system. In \nthe current GPT header that we are analyzing, these bytes are  1D \nF1 B0 D6  43 BE 37 4E B1 E6 38 66 EC B1 73 89. We can convert \nthem to the standard GUID format  of the disk by just reformatting \nthem as 1DF1B0D6 -43BE -374E -B1E6 -3866ECB17389.  \n11. Partition Entry Array LBA: This LBA address indicates the start of \nthe Partition Entry Array which we are going to discuss ahead as \nthe 3rd component of the GPT.  \n12. Number of Partition Entries: This field indicates the number of \npartitions that are on the disk. The GPT supports 128 partitions, \nunlike the MBR, which supports 4 partitions only. The value of this \nfield is  80 00 00 00 which if converted to decimal will be 128.  \n13. Size of Each Partition Entry: This field indicates the size occupied \nby each partition entry array. In this example, it set to  80 00 00 00 \nwhich is 128 in decimal. It is important to note that this is not the \n\n=== Page 7 ===\n\nsize of the partition itself. This is just the size of partition entry \narray that we would be discussing next.  \n14. CRC32 of Partition Array:  This is the CRC32 checksum of the whole \npartition entry array, which if changed, would indicate that either \nthe partition entry array is tampered or corrupted.  \nPartition Entry Array  \nWe saw that sector zero was occupied by the Protective MBR, and the \nGPT header occupied sector 1. Now, from sector 2, the Partition Entry \nArray starts, just like the partition table present in the MBR, with a few \ndifferences. There are a total of 128 parti tions on a GPT disk, and this \npartition entry array contains information about all these \npartitions.   Below is the screenshot of the Partition Entry Array of a GPT \ndisk. Each partition entry is represented by 128 bytes.   You can only see \nthe 6 partition en tries out of the total 128 partition entries of the GPT. \nThis is because there are only six working partitions in this disk. These six \npartitions would be present in blocks (128 bytes each) in this partition \nentry array, and after these working partitions,  all the remaining 122 \npartition entries would be marked with 00.    \n\n=== Page 8 ===\n\n \nLet's use the first partition of the above screenshot as a reference to \nanalyze the meaning of all the hexadecimal digits present in it.  \nThe screenshot below shows the first partition entry from the partition \nentry array of the GPT. All the bytes (or groups of bytes) have some \nspecific meaning. We have highlighted the different byte groups with \ndifferent colors.   \n\n\n=== Page 9 ===\n\n \nThe table below shows the fields represented by these bytes.   \nBytes \nPosition  Bytes \nLength  Bytes  Field Name  \n0-15 16 28 73 2A C1 1F F8 D2 11 BA 4B \n00 A0 C9 3E C9 3B  Partition Type \nGUID  \n16-31 16 9E 43 0D 72 EC 12 54 44 8F B2 \nEE 17 8D F3 CD 3B  Unique Partition \nGUID  \n32-39 8 00 08 00 00 00 00 00 00  Starting LBA  \n40-47 8 FF 27 03 00 00 00 00 00  Ending LBA  \n48-55 8 00 00 00 00 00 00 00 80  Attributes  \n56-127 72 45 00 46 00 49 00 20 00 73 00 \n79 00 73 ...  Partition Name   \nEach of these six fields has a specific purpose. Below is an explanation of \nall these fields.   \n1. Partition Type GUID: This is the GUID of the partition type. This \nGUID will indicate the partition type, i.e., EFI System Partition, \nBasic Data Partition, etc. The 16 bytes of our partition entry are \nstored in mixed endian (little -endian and big -endian) format. This \nmeans we w ould have to reverse specific bytes and keep the other \nones the same. In this case, we would do the following:  \n1. Reverse the first 4 bytes from  28 73 2A C1 to C1 2A 73 28,  as \nthey are in little -endian format.  \n2. Reverse the next 2 bytes from  1F F8 to F8 1F,  as they are in \nlittle -endian format.  \n\n\n=== Page 10 ===\n\n3. Reverse the next 2 bytes from  D2 11 to 11 D2  as they are in \nlittle -endian format.  \n4. Keep the next 2 bytes  BA 4B  as it is, as they are in big -\nendian format.  \n5. Keep the last 6 bytes  00 A0 C9 3E C9 3B  as it is, as they are \nin big -endian format.  \nThe resulting GUID from steps 1 -5 will be  C12A7328 -F81F -11D2 -BA4B -\n00A0C93EC93B. Whatever GUID you get from here, you can search it on \nthe internet to get the partition type associated with that GUID. The \nGUID we calculated is used for EFI System Partition (ESP).  \nEFI System Partition  (ESP)  is stored as a partition on every GPT disk and \nit is a very critical component in the boot process. In the MBR, we saw \nthat the bootloaders are located in the bootcode and the bootable \npartition. In contrast, in the GPT, the bootloader is comprised of mul tiple \nfiles with .efi extension, and they all are stored in this EFI System \nPartition (ESP).  Once the bootloader is found from the EFI System \nPartition, it loads the  Operating System's kernel  from the bootable \npartition of the disk, and after that, the dri vers, services, and filesystems \nare loaded into the memory. Then the user is given the control of OS \ninterface.  \n1. Unique Partition GUID: Unique Partition GUID is used to \ndistinguish partitions on a disk. It is a unique GUID that is given to \nall the partitions on the disk. To convert these hexadecimal bytes \ninto the standard GUID format, you can follow the same steps as \nwe did for the first field (Partition Type GUID), as this is also stored \nin the mixed endian format.  \n2. Starting LBA: The starting LBA address indicates the area from \nwhere this partition starts on the disk.   \n3. Ending LBA: The ending LBA address indicates the area at which \nthis partition is ending on the disk.  \n4. Attributes: This field contains some flags that indicates some \nfeatures of the partition, for example, if it is bootable, hidden, or \nnormal.  \n\n=== Page 11 ===\n\n5. Partition Name: This is the last field of the partition entry, and its \nsize is 72 bytes. It represents the name of the partition in string \nformat and is UTF -16 encoded. If you decode these bytes using \nany online hex -to-string decoder, you will get the partition name \nof th is partition.  \nBackup GPT Header  \nOne of the biggest reasons the GPT replaced the MBR is its redundancy. \nIn case of the MBR, if your MBR gets corrupted or changed due to \nhardware issues or malicious attacks, you have a minimal chance of \nrecovery. On the other hand, the GPT has backups of i ts components. \nThe Backup GPT Header is located at the last sector of the disk, and it \ncan be used for recovery in case the Primary GPT Header is corrupted. It \ncontains the same information as the Primary GPT Header.  \nBackup Partition Entry Array  \nThere is also a backup copy of the partition entry array. It is stored at the \nend of the disk just before the backup GPT header. It contains the same \ninformation as the partition entry array. It acts as a fail -safe mechanism \nin case the original partition entry array is damaged.  \nAnswer the questions below  \nHow many partitions are supported by the GPT?  \n128 \nWhat is the partition type GUID of the 2nd partition given in the \nattached GPT file?  \nE3C9E316 -0B5C -4DB8 -817D -F92DF00215AE  \n  \n\n=== Page 12 ===\n\n \n- UEFI Bootkit Case  \n \nWhen we use BIOS firmware, the bootloader responsible for loading the \noperating system is executed inside the MBR. However, when we use \nUEFI firmware, which supports a GPT partitioning scheme, the \nbootloader is not executed from the GPT. Instead, it is loc ated in the EFI \nsystem partition (ESP) in the form of .efi extension files. These files \ninclude the  bootmgr.efi , bootx64.efi , and others, depending on the OS.  \nEarlier, we studied the bootloader code in the MBR, which can be \ntampered with, and a bootkit can reside there. Conversely, using UEFI \nfirmware with the GPT, bootkits can reside in the .efi files in the ESP \npartition. However, this can only be successful i f the secure boot feature \nof UEFI is disabled. Once enabled, the secure boot feature will verify the \ndigital signatures of the bootloaders (.efi files) in the ESP and will not \nallow any tampered file to execute.  \nScenario  \nA bootkit was detected in an organization's critical Windows server. The \norganization reported no damage yet, as the bootkit was contained \nduring the initial stages. However, it is suspected that the bootkit was \nable to modify the bootloader files to some extent and embedded an \nencoded string in the initial unused space of the bootloader. The \nbootloader file, bootmgr.efi,  is located at C: \\Analysis \\bootmgr.efi. You \nare tasked with analyzing the tampered file in the HxD hex editor.   \nAnswer the questions below  \nWhich partition has the bootloader in it?  \nEFI System Partition  \nWhat is the malicious string embedded in the bootloader?  \nYou have been hacked by  Masb  ",
  "FAT32 Analysis.pdf": "\n\n=== Page 1 ===\n\nFAT3 2 Analysis  \n \n- Filesystem Analysis Techniques  \nThere are many techniques for analyzing the FAT32 filesystem. These \ntechniques are not unique to the FAT32 filesystem and can also be used \nto examine different filesystems. We can divide these techniques into \nroughly two categories: file system integrity and structural analysis  and \ndata recovery and content analysis . In the next tasks, we will do a \nhands -on activity to explore the more commonly used techniques.  \nFilesystem Integrity and Structural Analysis   \nThis category focuses on detecting corruption, tampering, and anomalies \nin the filesystem by analyzing its metadata, structural consistency, and \norganization. More often than not, we will combine several techniques \nto do our analysis. The table below shows  each technique we can apply \nto the FAT32 filesystem, together with the fields needed and a short \ndescription of what the technique encompasses.    \nAnalysis Technique  Related FAT32 \nField(s)  Description  \nCluster Chain \nAnalysis  File Allocation \nTable (FAT), Root \nDirectory Entries  Tracks and analyzes cluster \nchains to reconstruct \nfragmented files and detect \nallocation anomalies.  \nDirectory Structure \nand File Name \nAnalysis  Directory Entries \n(File Name, \nAttributes, First \nCluster)  Investigates file names, \nattributes, and directory \nstructures for hidden or deleted \nfiles.  \nVolume Serial \nNumber and Boot \nSector Analysis  Boot Sector \n(BPB), Volume \nMetadata  Analyzes metadata such as \nvolume label, serial number, \nsector size, and file system \nversion for tampering or \ninconsistencies.  \n\n=== Page 2 ===\n\nAnalysis Technique  Related FAT32 \nField(s)  Description  \nAnalyzing FAT Table \nCorruption or \nManipulation  FAT, Backup FAT, \nRoot Directory  Detects inconsistencies or \ntampering by comparing the \nprimary FAT with its backup and \nanalyzing cluster allocation.  \nExamining System \nVolume Information \n(Windows only)  Reserved \nMetadata Files, \nRoot Directory  Analyzes Windows -specific \nsystem files, such as System \nVolume Information, for user \nactivity or tampering evidence.  \nCorruption and \nTampering \nDetection  FAT, Boot Sector, \nDirectory Entries  Detects tampering or corruption \nby verifying file system \nstructures and metadata \nintegrity.  \nData Recovery and Content Analysis   \nThis category focuses on recovering deleted or hidden data, checking \ndata in allocated and unallocated spaces, and searching for specific \ncontent patterns. We can combine multiple of these techniques to \nensure a holistic analysis.  The table below shows eac h technique we can \napply to the FAT32 filesystem, together with the fields needed and a \nshort description of what the technique encompasses.  \nAnalysis \nTechnique  Related FAT32 \nField(s)  Description  \nFile Carving  Unallocated Clusters, \nData Area  Recovers files by searching for file \nheaders/footers or specific \npatterns in unallocated space.  \nSlack Space \nAnalysis  Data Clusters, \nDirectory Entries  Examines unused space within \nallocated clusters for residual or \nhidden data.  \n\n=== Page 3 ===\n\nAnalysis \nTechnique  Related FAT32 \nField(s)  Description  \nDeleted File \nRecovery  Directory Entries \n(Status Byte, First \nCluster), FAT  Recovers deleted files by \nanalyzing directory entries \nmarked as deleted and \nreconstructing cluster chains.  \nKeyword and \nPattern \nSearch  Unallocated Clusters, \nData Area  Searches for specific strings, \npatterns, or file signatures across \nallocated and unallocated space \nfor evidence.  \nTimeline \nAnalysis  Last Access Date, \nCreation Date/Time, \nLast Modified \nDate/Time  Builds a timeline of file and folder \nactivities using timestamps from \ndirectory entries.  \nNow that we know which techniques are available, let’s proceed to the \nnext task and get hands -on experience with them.  \n  \n\n=== Page 4 ===\n\n- T1564.001 Hidden Files and Directories  \nIn the FAT32 overview task, we briefly mentioned the MITRE ATT&CK \nTTPs linked to FAT32. In this and the following tasks, we will cover some \nof these TTPs in a practical setting and use the analysis techniques \nmentioned in the previous task. We will start w ith the MITRE technique \nT1564.001 Hidden Files and Directories.  \nMany attackers will set their malicious directories and files to be hidden \nto prevent detection or avoid file deletion by wary users. A standard user \noften does not have settings configured on their OS to show hidden files. \nFor example, a user finds a rela tively new USB and plugs it into his \nsystem. He then opens the USB folder and sees nothing. This makes the \nuser happy, he just got a free USB, but it makes an attacker equally \ndelighted. The one that will be less happy is the security team.  \nWithin the FAT32 filesystem, it is easy to alter a file’s attributes because \nno permission system is implemented. Let’s look at how we can find \nhidden files and directories on a FAT32 USB image. Before we begin, it is \nimportant to note that when doing fore nsic analysis, we often start with \na copy of the original volume image that needs to be analyzed. This is \nimportant so we don’t alter the original evidence and render it useless.  \nManual Analysis  \nTo find hidden files or directories on a FAT32 image, we will need to \nanalyze the SFN entries in the Root Directory. We can apply the analysis \ntechnique of  Directory Structure and File Name Analysis from task 6  to \nreach our goal.  \nRemember that an SFN entry is 32 bytes long. We are interested in the \nvalue of the 12th byte of the SFN entry. This byte represents the \nattributes of a file or directory. The file or directory is hidden if the byte \nis set to 0x02.  \nLet’s look at the FAT32 image that the user found. Navigate to the VM \nand use the HxD editor to open FAT32_HIDDEN.001 in \nC:\\FAT32_analysis \\. Once the image has loaded, press CTRL+G and enter \nthe hex value 00400000 to navigate to the root directory (This va lue is \ndetermined by analyzing the boot sector). In the image below, we can \nsee that there are multiple entries.  \n\n=== Page 5 ===\n\n \nLet’s look at each of them and see which entries are hidden. But before \nthat, we should first check if the root directory is not fragmented  (split \nover multiple clusters); otherwise, we could miss valuable information. In \nour case, the directory entries and file entries are split. For efficiency \nreasons, Windows often splits the file and directory entries and maps \nthem to a different cluster.  There are root directory entries on the \nclusters starting with offsets  00400200 and 00400600.  \nDirectories  \nLet’s start by looking at the entries of the first cluster, which starts at \noffset 00400000. The image below highlights two interesting entries.  \n \nThe first entry is an LFN entry that links to the second one, an SFN entry. \nLet’s zoom in on the SFN entry starting at offset 004000A0.  \nOffset  Size Field Name  Value \n(Hex)  Meaning  \n0x00  8 \nbytes  File Name  4D 40 4C \n4C 30 56 \n33 20  “M@LL0V3”  \n\n\n=== Page 6 ===\n\nOffset  Size Field Name  Value \n(Hex)  Meaning  \n0x08  3 \nbytes  File Extension  20 20 20  Space -filled (no file extension)  \n0x0B  1 \nbyte  File Attributes  13 Read -only + Hidden + Directory \n(0x01 + 0x02 + 0x10)  \n0x0C  1 \nbyte  Reserved (NT)  00 Reserved for NT (unused, zero -\nfilled)  \n0x0D  1 \nbyte  Creation Time \n(tenths)  B6 182 tenths of a second  \n0x0E  2 \nbytes  Creation Time  CD 81  Time: 16:14:26 (binary decoded \nas hours:minutes:seconds)  \n0x10  2 \nbytes  Creation Date  94 59  Date: Friday, December 20th, \n2024  (binary decoded as year, \nmonth, day)  \n0x12  2 \nbytes  Last Access \nDate  94 59  Date: Friday, December 20th, \n2024  (same as creation date)  \n0x14  2 \nbytes  High -Order \nCluster \nNumber  00 00  High word of the first cluster  \n0x16  2 \nbytes  Last \nModification \nTime  CE 81  Time: 16:14:28  \n0x18  2 \nbytes  Last \nModification \nDate  94 59  Date: Friday, December 20th, \n2024  \n0x1A  2 \nbytes  First Cluster \nNumber  05 00  Cluster 5  \n\n=== Page 7 ===\n\nOffset  Size Field Name  Value \n(Hex)  Meaning  \n0x1C  4 \nbytes  File Size  00 00 00 \n00 File size = 0 bytes => This \nindicates that the entry is a \ndirectory  \nBased on the information in the table above, we can conclude the \nfollowing things for this SFN entry:  \n• The entry represents a directory with the name M@LL0v3.  \n• The directory has the attributes hidden and read -only.  \n• It was created on December 20th, 2024 at 16:14:27.  \n• The directory contents start at cluster 5 (the actual cluster number \nis 3. The first two clusters should not be counted as they are \nvirtual, reserved clusters).  \nLook at that. We have found a hidden directory. Let’s analyze the other \nroot directory entries in the next clusters to see if we can find more \nvaluable forensic evidence.  \nFiles  \nNavigate to the cluster starting with offset 00400200 by pressing CTRL+G \nin the HxD editor and entering the offset value. You should see the same \nentries displayed in the image below.  \n \nThese entries are standard on a Windows FAT32 partition. Windows and \nits services use the WPSettings.dat file to store information related to \nindexing, backup, and more. The other entries refer to the current \ndirectory (.) and the parent directory (..)  \n\n\n=== Page 8 ===\n\nLet’s examine the next cluster. Navigate to the cluster starting with offset \n00400600. You should see the same entries displayed in the image \nbelow. The entries of interest are highlighted.  \n \nThe highlighted entries are, respectively, an LFN and an SFN. The LFN \nentry links to the SFN entry. Let’s examine the SFN entry starting at offset \n00400680.  \nOffset  Size Field Name  Value \n(Hex)  Meaning  \n0x00  7 \nbytes  File Name  42 45 4D \n59 56 41 \n7E 31  BEMYVA~1 (Shortened version \nof the long file name \n“BeMyValent1ne.txt”)  \n0x08  3 \nbytes  File Extension  54 58 54  TXT (File extension for a text file)  \n0x0B  1 \nbyte  File Attributes  02 Hidden  file attribute (0x02)  \n0x0C  1 \nbyte  Reserved (NT)  00 Reserved for NT (not used, set to \nzero)  \n0x0D  1 \nbyte  Creation Time \n(tenths)  B6 182 tenths of a second  \n0x0E  2 \nbytes  Creation Time  CD 81  Time : 16:14:26 (binary decoded \nas hours:minutes:seconds)  \n0x10  2 \nbytes  Creation Date  94 59  Date : Friday, December 20th, \n2024 (binary decoded as year, \nmonth, day)  \n\n\n=== Page 9 ===\n\nOffset  Size Field Name  Value \n(Hex)  Meaning  \n0x12  2 \nbytes  Last Access \nDate  94 59  Date : Friday, December 20th, \n2024  \n0x14  2 \nbytes  High -Order \nCluster \nNumber  00 00  High -order word of the first \ncluster (only used in FAT32, 0 for \nFAT16/FAT12)  \n0x16  2 \nbytes  Last \nModification \nTime  CE 81  Time : 16:14:28  \n0x18  2 \nbytes  Last \nModification \nDate  94 59  Date : Friday, December 20th, \n2024  \n0x1A  2 \nbytes  First Cluster \nNumber  06 00  Cluster : 6 (starting cluster for \nthe file’s content)  \n0x1C  4 \nbytes  File Size  17 00 00 \n00 Size: 23 bytes  \nBased on the information in the table above, we can conclude the \nfollowing things for this SFN entry:  \n• The entry refers to a text file named BeMyValent1ne.txt.  \n• The file has the attribute hidden.  \n• The file was created on the 20th of December, 2024 at 16:14:26.  \n• The file was last edited on the 20th of December, 2024 at \n16:14:28.  \n• The file was last accessed on the 20th of December, 2024.  \n• The file content can be found starting from cluster 6 (The actual \ncluster number is 4. The first two clusters should not be counted \nas they are virtual).  \nWe have found a hidden file. Let’s navigate to cluster 4 and check the \ncontent of this file. Press CTRL+G and navigate to the offset 00400810.  \n\n=== Page 10 ===\n\nAutomated Analysis  \nManual analysis can be quite lengthy. It is also prone to mistakes during \nthe various calculations that need to be made. To speed up our analysis, \nwe can use automated tools. We will use Autopsy  to analyze the \nFAT32_HIDDEN image and find the relevant forensic artifacts.  \nNow open Autopsy by navigating to the Desktop and double -clicking its \nicon. You should see the following screen.  \n \nYou see in screen  file name BeMyValent1n.txt  the Attribute  is File, \nHidden  and you see all the information about that file  . \n  \n\n\n=== Page 11 ===\n\n- T1070.006 Indicator Removal: Timestomp  \nAttackers will often change the timestamps of files to evade detection. \nThere are several types of timestamps an attacker can modify:  \n• Creation time  \n• Last access time  \n• Modify time  \nDepending on the attacker’s goal, he will change one or multiple of \nthem. Some examples:  \n• An attacker edits a legitimate configuration file on the target \nmachine. To ensure the changes are not easily picked up, he alters \nthe Last access time and the Modify time.  \n• An attacker adds a new file to a folder, checks the timestamps of \nthe other files, and modifies his file accordingly so the timestamps \nare similar.  \nDepending on the sophistication of the attacker, he might make some \nmistakes while altering timestamps. Some examples are:  \n• The creation timestamp is later than its last modified or accessed \ntimestamp.  \n• The timestamps are very old or recent compared to other files in \nthe folder.  \nDetecting time stomping is not always easy, even less so with FAT32 since \nit doesn’t implement journaling. There are some key detection \ntechniques we can use:  \n• We can cross -reference the file’s current timestamps with other \nlog records of the file’s timestamps. For example, we can use \nWindows Event logs and compare them with data we retrieved \nfrom the image.  \n• We can implement tools that monitor file integrity.  \n• We can focus on detecting tools that can alter timestamps like \ntimestamp.exe. We can focus on looking for inconsistencies in the \n\n=== Page 12 ===\n\ntimestamps, such as the creation time being later than the last \naccessed time.  \nIn this task, we will look for inconsistencies in the timestamps. Similar to \nthe previous task, we will first analyze an image manually with the HxD \neditor and then use Autopsy for automated analysis. The analysis \ntechniques we can use here are Timeline Analysis and Directory \nStructure and File Name Analysis discussed in task 6.  \nManual Analysis  \nContinuing with the VM, open the HxD editor, navigate to the menu bar, \nclick file, and then open. Navigate to the C: \\FAT32_analysis \\ directory, \nselect the image FAT32_TIMESTOMP .001, and click Open.  \nNavigate to offset 00400000 by pressing CTRL+G and entering the offset \nvalue. Similar to the image in the previous task, the root directory is \nspread over 3 clusters. We will take each cluster’s SFN entries and gather \nthe timestamps. The results are displa yed in the table below.  \nName  Modified \nDate  Modified \nTime  Last \nAccess \nDate  Creation \nDate  Creation \nTime  \n[current folder]  2024 -11-\n27 17:02:30  2025 -01-\n07 2025 -01-\n07 10:38:50  \n[parent folder]  0000 -00-\n00 00:00:00  0000 -00-\n00 0000 -00-\n00 00:00:00  \n_EWCOM~1.ZIP  2025 -01-\n07 10:39:26  2025 -01-\n07 2025 -01-\n07 10:39:25  \nchangelog.txt  2021 -01-\n10 16:06:00  2025 -01-\n07 2025 -01-\n07 10:38:50  \nHxD.exe  2021 -02-\n10 22:20:12  2025 -01-\n07 2025 -01-\n07 10:38:50  \ninstall.txt  2021 -01-\n10 16:04:00  2018 -01-\n10 2025 -01-\n07 10:39:33  \n\n=== Page 13 ===\n\nName  Modified \nDate  Modified \nTime  Last \nAccess \nDate  Creation \nDate  Creation \nTime  \nlicense.txt  2021 -01-\n10 16:03:02  2025 -01-\n07 2025 -01-\n07 10:38:50  \nNew Text \nDocument.txt  2025 -01-\n07 10:39:34  2025 -01-\n07 2025 -01-\n07 10:39:33  \nreadme.txt  2021 -01-\n10 16:06:56  2025 -01-\n07 2025 -01-\n07 10:38:50  \nunins000.dat  2024 -11-\n27 17:02:32  2025 -01-\n07 2025 -01-\n07 10:38:50  \nunins000.exe  2024 -11-\n27 17:02:28  2025 -01-\n07 2025 -01-\n07 10:38:50  \nFindings  \n• When we compare the Creation Date with the Modified Date, you \nwill notice that the files were modified before they were created. \nThis is standard behavior when you copy an existing folder with \nfiles to a new location. The modified timestamp is preserved, b ut \nthe access and creation timestamps are updated.  \n• The table has a file with an anomaly: the  last Access Date is earlier \nthan the Modified Date. Enter the filename.extension as the \nanswer to question 1.  \nAs you have noticed, it is time -intensive to calculate all the different \ntimestamps for every file. For example, you could write a script yourself, \nbut there is no need to reinvent the warm water. Let’s use Autopsy to \nmake our work easier.  \nAutomated Analysis  \nAnalyzing an image to look for traces of time stomping is best done using \nan automated tool like Autopsy. The image we are using was adjusted for \nthis task and did not contain many entries. In real -life scenarios, there \nwill often be many more entries to a nalyze. Autopsy has an excellent \n\n=== Page 14 ===\n\nfeature called Timeline that allows us to see a timeline of all the files. \nLet’s take a look at the image using Autopsy.  \nOpen Autopsy, create a new case and add the image \nFAT32_TIMESTOMP .001 as a  Data Source (similar to what we did in task \n7). \nSimilar to the previous task, we can explore the structure of the image by \nnavigating to Data Sources -> FAT32_TIMESTOMP .001_1 Host -> \nFAT32_TIMESTOMP .001. We can then explore the folders and list the \ndetails of the files in those folders. Processing and a nalyzing the data this \nway still requires some time. As mentioned before, Autopsy includes a \ntool called Timeline, designed for analyzing timestamps. We will use this \ntool for our analysis.  \nClick on Timeline in the toolbar as highlighted in the image below.  \n \nYou should now see a new window titled Timeline Editor. This window \nshows a graph with all the timestamps of each file on the image. Adjust \nthe start and end datetime to the range highlighted in the image below \nand change the Scale to Linear. The Linear op tion makes seeing the \nnumber of events for any given year easier.  \n\n\n=== Page 15 ===\n\n \nBefore we continue analyzing, it is important to note that you should \nconfigure the Display Times In option according to the standard you \nagree on with your team. You should be consequent with the chosen \noption, as it can alter the analysis results signifi cantly. If your team only \nworks in one location without any 3rd parties, it would make sense to \nconfigure it to Local Time Zone. This way, the timestamps can easily be \nmatched with, for example, working hours.  \nThe graph displays four bars, each representing a year. Depending on the \nnumber of events in a particular year, the bar will be higher or lower. \nClick on the bar representing the year 2021. In the lower -left corner, you \nshould now see a table with all the events for that year, as shown in the \nimage below. The table shows theEvent Type, Description of the file, and \nDate/Time.  \n\n\n=== Page 16 ===\n\n \nClick on an event in the table to see more details in the right pane, as \nshown in the image below.  \n \nThe graph shows a single event in 2018. This is worth investigating since \nit occurred three years before the files were modified in 2021.  \nClick on the bar representing 2018 and look at the table in the lower left \ncorner. It seems we have a single event for a File Accessed without any \nprior File Creation event. This is suspicious. Select the record in the table \nand look at the details in the right pane. Enter the flag as the answer to \nquestion 2 at the end of this task.  \nFindings  \n\n\n=== Page 17 ===\n\nWe have arrived at the same conclusion as the manual analysis. The \ninstall.txt file is suspicious. It has an Accessed timestamp without any \nCreation timestamp prior. This is not standard behavior.  \nLet's continue to the next task to discuss another MITRE technique.  \n \nAnswer the questions below : \nWhat is the file name of suspicious file  ? \nInstall.txt  \n \nWhat is the Accessed timestamp of the discovered suspicious file?  \n2024 -12-03 00:00:00  \n \nWhat is the flag found during the automated analysis?  \nFlag{M@s8 1s 8est H@cker}  \n \n \n  \n\n=== Page 18 ===\n\n- T1070.004 File Deletion and T1070.009 Clear Persistence  \n \nMITRE ATT&CK techniques T1070.004 File Deletion and T1070.009 go \nhand in hand. An attacker will delete any evidence that could be traced \nback to them, or that could help a defender undo the attack. Clearing \npersistence is broader than just deleting files o n disk, but for the context \nof this task, we will narrow the scope to detecting persistence on a FAT32 \npartition.  \nIn this task we will analyze a FAT32 image that contains deleted files and \nretrieve its contents. We will start with manual analysis by opening the \nFAT32 image in the HxD editor, then continue with automated analysis \nusing Autopsy.  \nManual Analysis  \nContinuing with the VM, open the HxD editor, navigate to the menu bar, \nclick file, and then open. Navigate to the C: \\FAT32_analysis \\ directory, \nselect the image   FAT32_DELETED.001, and click Open.  \nNavigate to offset 00400000 by pressing CTRL+G and entering the offset \nvalue. Similar to the image in the previous task, the root directory is \nspread over multiple clusters. In this FAT32 image, the clusters assigned \nto the root directory are non -contiguou s. We have to look at the FAT \ntable entries to deduct where the root directory entries continue —the \nFAT entry for the root directory points at cluster 17. So, we should find \nthe next root directory entries starting from cluster 15 (17 minus two \nvirtual res erved clusters). Cluster 15 starts at offset 00401E00.  \nNow that we have located all the root directory entries, we can analyze \nthem and find deleted files. We are looking for entries starting with the \nhexadecimal value E5. Below is an overview of all the SFN root directory \nentries. For each entry, we listed th e filename and the hexadecimal \nvalue. Additionally, we have highlighted the deleted entries.  \n \n\n=== Page 19 ===\n\nFilename  Hexadecimal Value  \nFAT32_DEL  46 41 54 33 32 5F 44 45 4C 20 20 08 00 00 00 00 00 00 \n00 00 00 00 24 77 29 5A 00 00 00 00 00 00  \nSYSTEM~1  53 59 53 54 45 4D 7E 31 20 20 20 16 00 98 23 77 29 5A \n29 5A 00 00 24 77 29 5A 03 00 00 00 00 00  \nFILE6.TXT  46 49 4C 45 36 20 20 20 54 58 54 20 18 3B 42 78 29 5A \n29 5A 00 00 6C 4B 28 5A 0A 00 5E 00 00 00  \nFILE7.TXT  46 49 4C 45 37 20 20 20 54 58 54 20 18 3B 42 78 29 5A \n29 5A 00 00 6C 4B 28 5A 0B 00 5E 00 00 00  \nFILE8.TXT  46 49 4C 45 38 20 20 20 54 58 54 20 18 3C 42 78 29 5A \n29 5A 00 00 6C 4B 28 5A 0C 00 5E 00 00 00  \nFILE9.TXT  46 49 4C 45 39 20 20 20 54 58 54 20 18 3C 42 78 29 5A \n29 5A 00 00 6C 4B 28 5A 0D 00 5E 00 00 00  \nFILE10.TXT  46 49 4C 45 31 30 20 20 54 58 54 20 18 3C 42 78 29 5A \n29 5A 00 00 6D 4B 28 5A 0E 00 5E 00 00 00  \nFILE11.TXT  46 49 4C 45 31 31 20 20 54 58 54 20 18 3D 42 78 29 5A \n29 5A 00 00 6D 4B 28 5A 0F 00 5E 00 00 00  \nFILE12.TXT  46 49 4C 45 31 32 20 20 54 58 54 20 18 3D 42 78 29 5A \n29 5A 00 00 6D 4B 28 5A 10 00 5E 00 00 00  \nFILE13.TXT  46 49 4C 45 31 33 20 20 54 58 54 20 18 3E 42 78 29 5A \n29 5A 00 00 6D 4B 28 5A 12 00 5E 00 00 00  \nFILE14.TXT  46 49 4C 45 31 34 20 20 54 58 54 20 18 3E 42 78 29 5A \n29 5A 00 00 6D 4B 28 5A 13 00 5E 00 00 00  \nFILE15.TXT  46 49 4C 45 31 35 20 20 54 58 54 20 18 3F 42 78 29 5A \n29 5A 00 00 6D 4B 28 5A 14 00 5E 00 00 00  \nFILE16.TXT  46 49 4C 45 31 36 20 20 54 58 54 20 18 3F 42 78 29 5A \n29 5A 00 00 6D 4B 28 5A 15 00 5E 00 00 00  \n\n=== Page 20 ===\n\nFilename  Hexadecimal Value  \nFILE17.TXT  46 49 4C 45 31 37 20 20 54 58 54 20 18 40 42 78 29 5A \n29 5A 00 00 6D 4B 28 5A 16 00 5E 00 00 00  \nFILE18.TXT  46 49 4C 45 31 38 20 20 54 58 54 20 18 41 42 78 29 5A \n29 5A 00 00 6D 4B 28 5A 17 00 5E 00 00 00  \nFILE19.TXT  46 49 4C 45 31 39 20 20 54 58 54 20 18 41 42 78 29 5A \n29 5A 00 00 6D 4B 28 5A 18 00 5E 00 00 00  \nFILE20.TXT  46 49 4C 45 32 30 20 20 54 58 54 20 18 41 42 78 29 5A \n29 5A 00 00 6D 4B 28 5A 19 00 5E 00 00 00  \n?.1 E5 73 00 31 00 00 00 FF FF FF FF 0F 00 9B FF FF FF FF FF \nFF FF FF FF FF FF FF 00 00 FF FF FF FF  \nCstrikepers.ps1  E5 43 00 73 00 74 00 72 00 69 00 0F 00 9B 6B 00 65 00 \n50 00 65 00 72 00 73 00 00 00 2E 00 70 00  \nSTRIKE~1.PS1  E5 53 54 52 49 4B 7E 31 50 53 31 20 00 68 47 78 29 5A \n29 5A 00 00 30 78 29 5A 1C 00 EC 01 00 00  \nThe highlighted entries are worth investigating. A first look shows that \nthey are LFN and SFN entries. Inspecting the filename, they seem linked. \nLet’s have a closer look at the SFN entry.  \nOffset  Size Field Name  Value (hex)  Meaning  \n0x00  11 File Name  E5 53 54 52 \n49 4B 7E 31 \n50 53 31  STRIKE~1.PS1  \n0x0B  1 Attributes  20 The file has the attribute \nARCHIVE  \n0x0C  1 Reserved  00 Reserved for use by \nWindows NT.  \n0x0D  1 Creation Time \n(Tenths)  68 14 ms  \n\n=== Page 21 ===\n\nOffset  Size Field Name  Value (hex)  Meaning  \n0x0E  2 Creation Time  47 78  15:02:15  \n0x10  2 Creation Date  29 5A  2025 -01-09 \n0x12  2 Last Access Date  29 5A  2025 -01-09 \n0x14  2 High Word of \nFirst Cluster  00 00  Cluster 28 (combination \nwith low word of first \ncluster)  \n0x16  2 Last \nModification \nTime  30 78  15:01:32  \n0x18  2 Last \nModification \nDate  29 5A  2025 -01-09 \n0x1A  2 Low Word of \nFirst Cluster  1C 00  Cluster 28 (combination \nwith high word of first \ncluster)  \n0x1C  4 File Size  EC 00 00 00  492 bytes  \nFindings   \nThe SFN entry refers to cluster 28 as the starting point for the file’s \ncontent. We can recover the content of the deleted file by navigating to \ncluster 28, which starts at offset 00403400, as shown in the image below.  \n \n\n\n=== Page 22 ===\n\nThe content of the PowerShell file seems completely intact. Since we are \nworking in a safe environment, we can try running the script to see what \nit does. Copy the recovered content and paste it into a PowerShell \nwindow. Enter the Flag as the answer to que stion 2.  \nLet’s move on to automated analysis to verify our results.  \nAutomated Analysis  \nSimilar to the previous tasks, manual analysis takes some time and is \nprone to mistakes during the various calculations. The image provided \nfor this task was also adjusted to make it easier to find the deleted files. \nIn reality, the size of the partition a nd the number of files and directories \nare much larger. Doing manual analysis would take up too much time. A \ntool like Autopsy can make this much easier for us. Let’s analyze the \nimage with Autopsy.  \nOpen Autopsy, create a new case and add the image \nFAT32_DELETED.001  as a Data Source  (similar to what we did in task 7).  \nSimilar to the previous task, we can explore the structure of the image by \nnavigating to  Data Sources,  FAT32_DELETED.001_1 \nHost,  FAT32_DELETED.001. We can then explore the folders and list their \ndetails.  \nThere are two locations where we can look for the deleted files:  \n• The directory where the file was deleted.  \n• The $RECYCLE.BIN directory.  \nLet’s first check the root of the image. Following the steps above, you \nshould already see a deleted file, as shown in the image below.  \n\n=== Page 23 ===\n\n \nSelect the file and verify its content. It should be the same as the file \ncontent we found during the manual analysis. You can also extract and \nsave the file by right -clicking it and selecting Extract File(s) as shown in \nthe image below.  \n \nNow, navigate to the $RECYCLE.BIN directory to see if there are other \ndeleted files. As we can see in the image below, there are two deleted \nentries. We found that these entries correspond with the LFN and SFN \nentries for the CstrikePers.ps1 file. Select e ach entry and confirm that it \nrelates to CstrikePers.ps1.  \n\n\n=== Page 24 ===\n\nFindings   \nWe found a deleted PowerShell file named CstrikePers.ps1. We were \nable to recover the file’s content completely and determine what the \nPowerShell script does when executed.  \nAnswer the questions below  \nWhich hexadecimal sequence identifies a deleted file?  \nE5 \n \nWhat is the output of the deleted PowerShell script after executing it? \nNote: In real -life investigations, we will only execute a suspicious file in \na sandboxed environment.  \nTWFzYntyM1RyITN2M0RfM3YhZDNuQzN9  \nMasb{r3Tr!3v3D_3v!d3nC3}  \n \n ",
  "Registry Forensics.pdf": "\n\n=== Page 1 ===\n\nRegistry and Forensics  \n \n- Windows Registry:  \nThe Windows Registry is a collection of databases that contains the \nsystem's configuration data. This configuration data can be about the \nhardware, the software, or the user's information. It also includes data \nabout the recently used files, programs used,  or devices connected to \nthe system. As you can understand, this data is beneficial from a \nforensics standpoint. Throughout this room, we will learn ways to read \nthis data to identify the required information about the system. You can \nview the registry usi ng regedit.exe, a built -in Windows utility to view and \nedit the registry. We'll explore other tools to learn about the registry in \nthe upcoming tasks.  \nThe Windows registry consists of Keys and Values. When you open the \nregedit.exe utility to view the registry, the folders you see are Registry \nKeys. Registry Values are the data stored in these Registry Keys. A \nRegistry Hive is a group of Keys, subkeys, and values stored in a single file \non the disk.  \nStructure of the Registry:  \nThe registry on any Windows system contains the following five root \nkeys:  \n1. HKEY_CURRENT_USER  \n2. HKEY_USERS  \n3. HKEY_LOCAL_MACHINE  \n4. HKEY_CLASSES_ROOT  \n5. HKEY_CURRENT_CONFIG  \nYou can view these keys when you open the regedit.exe utility. To open \nthe registry editor, press the Windows key and the R key simultaneously. \nIt will open a run prompt that looks like this:  \n\n=== Page 2 ===\n\n \nIn this prompt, type regedit.exe , and you will be greeted with the \nregistry editor window. It will look something like this:  \n \nHere you can see the root keys in the left pane in a tree view that shows \nthe included registry keys, and the values in the selected key are shown \nin the right pane. You can right -click on the value shown in the right pane \nand select properties to view the  properties of this value.  \nHere is how Microsoft defines each of these root keys. For more detail \nand information about the following Windows registry keys, please \nvisit  Microsoft's documentation . \n \n \n\n\n=== Page 3 ===\n\nFolder/predefined key  Description  \nHKEY_CURRENT_USER  Contains settings for the user who is currently logged in . \nExamples:  \n• Desktop background  \n• Mouse settings  \n• Window colors  \n• Control Panel preferences  \nChanges here affect only you , not other users.  \nHKEY_USERS  Contains profiles for all users  on the computer.  \nEach user has their own subkey here.  \nThe HKEY_CURRENT_USER (HKCU)  key is actually just a \nshortcut to your specific profile inside HKEY_USERS.  \nHKEY_LOCAL_MACHINE  This key controls file associations  — which program opens \nwhen you double -click a file.  \nFor example:  \n• .mp3 opens with your music player  \n• .docx opens with Microsoft Word  \nHKCR is actually a merged view  of two other keys:  \n• HKLM \\Software \\Classes  → Default settings for all \nusers  \n• HKCU \\Software \\Classes  → Custom settings for the \ncurrent user  \n If you change something under HKCU \\Software \\Classes , it \naffects only you.  \n If you change something under HKLM \\Software \\Classes , it \naffects everyone.  \n HKCR  combines both so older programs can still read them \neasily.  \n \n\n=== Page 4 ===\n\nHKEY_CLASSES_ROOT  Contains settings related to the hardware configuration  \ncurrently in use.  \nFor example:  \n• Graphics card settings  \n• Printer settings  \n• Audio configuration during startup  \ninformation under \nHKEY_LOCAL_MACHINE \\Software \\Classes .  \nIf you write values to a key under HKEY_CLASSES_ROOT, and \nthe key already exists under \nHKEY_CURRENT_USER \\Software \\Classes , the system will \nstore the information there instead of under \nHKEY_LOCAL_MACHINE \\Software \\Classes .  \nHKEY_CURRENT_CONFIG  Contains information about the hardware profile that is \nused by the local computer at system startup.  \n \nAnswer the questions below  \nWhat is the name of the hive that contain  settings for the user who is \ncurrently logged in ? \nHKEY_CURRENT_USER  \n \n \n  \n\n=== Page 5 ===\n\n \n-  Windows Registry:  \nf you are accessing a live system, you will be able to access the registry \nusing regedit.exe, and you will be greeted with all of the standard root \nkeys we learned about in the previous task. However, if you only have \naccess to a disk image, you must know w here the registry hives are \nlocated on the disk. The majority of these hives are located in the \nC:\\Windows \\System32 \\Config directory and are:  \n1. DEFAULT (mounted on HKEY_USERS \\DEFAULT)  \n2. SAM (mounted on HKEY_LOCAL_MACHINE \\SAM)  \n3. SECURITY (mounted on HKEY_LOCAL_MACHINE \\Security)  \n4. SOFTWARE (mounted on HKEY_LOCAL_MACHINE \\Software)  \n5. SYSTEM (mounted on HKEY_LOCAL_MACHINE \\System)  \nHives containing user information:  \nApart from these hives, two other hives containing user information can \nbe found in the User profile directory. For Windows 7 and above, a user’s \nprofile directory is located in C: \\Users \\<username> \\ where the hives are:  \n1. NTUSER.DAT  (mounted on HKEY_CURRENT_USER when a user \nlogs in)  \n2. USRCLASS.DAT  (mounted on \nHKEY_CURRENT_USER \\Software \\CLASSES)  \nThe USRCLASS.DAT hive is located in the directory \nC:\\Users \\<username> \\AppData \\Local \\Microsoft \\Windows.   \n\n=== Page 6 ===\n\n \n  \n\n\n=== Page 7 ===\n\nThe NTUSER.DAT hive is located in the directory  C:\\Users \\<username> \\. \n \nRemember that NTUSER.DAT and USRCLASS.DAT are hidden files.  \nThe Amcache Hive:  \nApart from these files, there is another very important hive called the \nAmCache hive. This hive is located \nin C:\\Windows \\AppCompat \\Programs \\Amcache.hve. Windows creates \nthis hive to save information on programs that were recently run on the \nsystem.  \n\n\n=== Page 8 ===\n\nTransaction Logs and Backups:  \nSome other very vital sources of forensic data are the registry \ntransaction logs and backups. The transaction logs can be considered as \nthe journal of the changelog of the registry hive. Windows often uses \ntransaction logs when writing data to registry hiv es. This means that the \ntransaction logs can often have the latest changes in the registry that \nhaven't made their way to the registry hives themselves. The transaction \nlog for each hive is stored as a .LOG file in the same directory as the hive \nitself. It  has the same name as the registry hive, but the extension is \n.LOG. For example, the transaction log for the SAM hive will be located in \nC:\\Windows \\System32 \\Config in the filename SAM.LOG. Sometimes \nthere can be multiple transaction logs as well. In that c ase, they will have \n.LOG1, .LOG2 etc., as their extension. It is prudent to look at the \ntransaction logs as well when performing registry forensics.  \nRegistry backups are the opposite of Transaction logs. These are the \nbackups of the registry hives located in \nthe C:\\Windows \\System32 \\Config directory. These hives are copied to \nthe C:\\Windows \\System32 \\Config \\RegBack directory every ten days. It \nmight be a n excellent place to look if you suspect that some registry keys \nmight have been deleted/modified recently.  \nAnswer the questions below  \n \nWhat is the path for the five main registry hives, DEFAULT, SAM, \nSECURITY , SOFTWARE, and SYSTEM?  \nC:\\Windows \\System32 \\Config  \n \nWhat is the path for the AmCache hive?  \nC:\\Windows \\AppCompat \\Programs \\Amcache.hve   \n\n=== Page 9 ===\n\n- Data Acquisition  \nWhen performing forensics, we will either encounter a live system or an \nimage taken of the system. For the sake of accuracy, it is recommended \npractice to image the system or make a copy of the required data and \nperform forensics on it. This process is cal led data acquisition. Below we \ndiscuss different ways to acquire registry data from a live system or a disk \nimage:  \nThough we can view the registry through the registry editor, the \nforensically correct method is to acquire a copy of this data and perform \nanalysis on that. However, when we go to copy the registry hives from \n%WINDIR% \\System32 \\Config , we cannot because it  is a restricted file. \nSo, what to do now?  \n \nFor acquiring these files, we can use one of the following tools:  \n \nAutopsy:  \nAutopsy  gives you the option to acquire data from both live systems or \nfrom a disk image. After adding your data source, navigate to the \nlocation of the files you want to extract, then right -click and select the \nExtract File(s) option. It will look similar to wha t you see in the \nscreenshot below.  \n \n\n\n=== Page 10 ===\n\nFTK Imager:  \nFTK Imager  is similar to Autopsy and allows you to extract files from a \ndisk image or a live system by mounting the said disk image or drive in \nFTK Imager. Below you can see the option to Export files as highlighted in \nthe screenshot.  \n \nAnother way you can extract Registry files from FTK Imager is through \nthe Obtain Protected Files option. This option is only available for live \nsystems and is highlighted in the screenshot below. This option allows \nyou to extract all the registry hives to a location of your choosing. \nHowever, it will not copy the Amcache.hve file, which is often necessary \nto investigate evidence of programs that were last executed.  \n\n\n=== Page 11 ===\n\n \nFor the purpose of this room, we will not be acquiring data ourselves, \nbut instead, we will work with the attached VM that already has data.  \n \n  \n\n\n=== Page 12 ===\n\n- Exploring Windows Registry  \nOnce we have extracted the registry hives, we need a tool to view these \nfiles as we would in the registry editor. Since the registry editor only \nworks with live systems and can't load exported hives, we can use the \nfollowing tools:  \nRegistry Editor :  \nAs we can see in the screenshot below,  you can see all the registry in tree \nview . \n \n \nZimmerman's Registry Explorer:  \nEric Zimmerman has developed a handful of tools that are very useful for \nperforming Digital Forensics and Incident Response. One of them is the \nRegistry Explorer. It looks like the below screenshot. It can load multiple \nhives simultaneously and add data from transaction logs into the hive to \nmake a more  'cleaner' hive with more up -to-date data. It also has a \nhandy 'Bookmarks' option containing forensically important registry keys \noften sought by forensics investigators. Investigators can go straight to \nthe interesting registry keys and values with the bo okmarks menu item. \nWe will explore these in more detail in the upcoming tasks.  \n\n\n=== Page 13 ===\n\n \n \n \n  \n\n\n=== Page 14 ===\n\n- System Information and System Accounts  \nNow that we have learned how to read registry data, let's find out where \nto look in the registry to perform our forensic analysis.  \nWhen we start performing forensic analysis, the first step is to find out \nabout the system information. This task will cover gathering information \nrelated to a machine's System and Account information.  \n \nData Acquisition  can be take from Software file from location \nC:\\Windows \\System32 \\config \\ \n1- SOFTWARE  \n2- SYSTEM   \nCOPY THIS FILE AND START INVESTEGATE .  \n \n \nOS Version:  \nIf we only have triage data to perform forensics, we can determine the \nOS version from which this data was pulled through the  registry. To find \nthe OS version, we can use the following registry key:  \nSOFTWARE \\Microsoft \\Windows NT \\CurrentVersion  \nThis is how Registry Explorer shows this registry key.  \n\n\n=== Page 15 ===\n\n     \nCurrent control set:  \nThe hives containing the machine’s configuration data used for \ncontrolling system startup are called Control Sets. Commonly, we will see \ntwo Control Sets, ControlSet001 and ControlSet002, in the SYSTEM hive \non a machine. In most cases (but not always), Con trolSet001 will point to \nthe Control Set that the machine booted with, and ControlSet002 will be \nthe last known good  configuration. Their locations will be:  \nSYSTEM \\ControlSet001  \nSYSTEM \\ControlSet002  \nWindows creates a volatile Control Set when the machine is live, called \nthe CurrentControlSet  ( HKLM \\SYSTEM \\CurrentControlSet ). For getting \nthe most accurate system information, this is the hive that we will refer \nto. We can find out which Control Set is being used as the \nCurrentControlSet by looking at the following registry value:  \nSYSTEM \\Select \\Current  \nSimilarly, the last known good configuration can be found using the \nfollowing registry value:  \nSYSTEM \\Select \\LastKnownGood  \nThis is how it looks like in Registry Explorer.  \n\n\n=== Page 16 ===\n\n \nIt is vital to establish this information before moving forward with the \nanalysis. As we will see, many forensic artifacts we collect will be \ncollected from the Control Sets.  \nComputer Name:  \nIt is crucial to establish the Computer Name while performing forensic \nanalysis to ensure that we are working on the machine we are supposed \nto work on. We can find the Computer Name from the following \nlocation:  \nSYSTEM \\CurrentControlSet \\Control \\ComputerName \\ComputerName   \nRegistry Explorer shows it like this. Take a look and answer Question # 3:  \n \nTime Zone Information:  \nFor accuracy, it is important to establish what time zone the computer is \nlocated in. This will help us understand the chronology of the events as \nthey happened. For finding the Time Zone Information, we can look at \nthe following location:  \nSYSTEM \\CurrentControlSet \\Control \\TimeZoneInformation  \nHere's how it looks in Registry Explorer. Take a look and answer Question \n# 4. \n\n\n=== Page 17 ===\n\n \nTime Zone Information is important because some data in the computer \nwill have their timestamps in UTC/GMT and others in the local time zone. \nKnowledge of the local time zone helps in establishing a timeline when \nmerging data from all the sources.  \nNetwork Interfaces and Past Networks:  \nThe following registry key will give a list of network interfaces on the \nmachine we are investigating:  \nSYSTEM \\CurrentControlSet \\Services \\Tcpip \\Parameters \\Interfaces  \nTake a look at this registry key as shown in Registry Explorer and answer \nQuestion # 5.  \n \n \n \nEach Interface is represented with a unique identifier (GUID) subkey, \nwhich contains values relating to the interface’s TCP/IP configuration. \nThis key will provide us with information like IP addresses, DHCP IP \naddress and Subnet Mask, DNS Servers, and mor e. This information is \nsignificant because it helps you make sure that you are performing \nforensics on the machine that you are supposed to perform it on.  \n\n\n=== Page 18 ===\n\nThe past networks a given machine was connected to can be found in \nthe following locations:  \nSOFTWARE \\Microsoft \\Windows \nNT\\CurrentVersion \\NetworkList \\Signatures \\Unmanaged  \nSOFTWARE \\Microsoft \\Windows \nNT\\CurrentVersion \\NetworkList \\Signatures \\Managed  \n \nThese registry keys contain past networks as well as the last time they \nwere connected. The last write time of the registry key points to the last \ntime these networks were connected.  \nAutostart Programs (Autoruns):  \nThe following registry keys include information about programs or \ncommands that run when a user logs on.   \nNTUSER.DAT \\Software \\Microsoft \\Windows \\CurrentVersion \\Run  \nNTUSER.DAT \\Software \\Microsoft \\Windows \\CurrentVersion \\RunOnce  \nSOFTWARE \\Microsoft \\Windows \\CurrentVersion \\RunOnce  \nSOFTWARE \\Microsoft \\Windows \\CurrentVersion \\policies \\Explorer \\Run  \nSOFTWARE \\Microsoft \\Windows \\CurrentVersion \\Run  \n \nThe following registry key contains information about services:  \nSYSTEM \\CurrentControlSet \\Services  \nNotice the Value of the Start key in the screenshot below.  \n\n\n=== Page 19 ===\n\n \nIn this registry key, if the start   key is set to 0x02, this means that this \nservice will start at boot.  \nSAM hive and user information:  \nThe SAM hive contains user account information, login information, and \ngroup information. This information is mainly located in the following \nlocation:  \nSAM \\Domains \\Account \\Users  \nTake a look at the below screenshot and answer Question # 6.  \n \nThe information contained here includes the relative identifier (RID) of \nthe user, number of times the user logged in, last login time, last failed \nlogin, last password change, password expiry, password policy and \npassword hint, and any groups that the use r is a part of.   \n  \n\n\n=== Page 20 ===\n\n \nAnswer the questions below :  \n \nWhat is the Current Build Number of the machine whose data is being \ninvestigated?  \nWhich ControlSet contains the last known good configuration?  \nWhat is the Computer Name of the computer?  \nWhat is the value of the TimeZoneKeyName?  \nWhat is the DHCP IP address  \nWhat is the RID of the Guest User account?  \n  \n\n=== Page 21 ===\n\nRecent Files:  \nWindows maintains a list of recently opened files for each user. As we \nmight have seen when using Windows Explorer, it shows us a list of \nrecently used files.   This information is stored in the NTUSER hive and \ncan be found on the following location:  \nNTUSER.DAT \\Software \\Microsoft \\Windows \\CurrentVersion \\Explorer \\Re\ncentDocs  \n \nRegistry Explorer allows us to sort data contained in registry keys quickly. \nFor example, the Recent documents tab arranges the Most Recently \nUsed (MRU) file at the top of the list. Registry Explorer also arranges \nthem so that the Most Recently Used (MRU) file is shown at the top of \nthe list and the older ones later.  \nAnother interesting piece of information in this registry key is that there \nare different keys with file extensions, such as   .pdf , .jpg , .docx  etc. \nThese keys provide us with information about the last used files of a \nspecific file extension. So if we are looking specifically for the last used \nPDF files, we can look at the following registry key:  \nNTUSER.DAT \\Software \\Microsoft \\Windows \\CurrentVersion \\Explorer \\Re\ncentDocs \\.pdf  \nRegistry Explorer also lists the Last Opened time of the files. Answer \nQuestion # 1 by looking at the above screenshot.  \nOffice Recent Files:  \nSimilar to the Recent Docs maintained by Windows Explorer, Microsoft \nOffice also maintains a list of recently opened documents. This list is also \nlocated in the NTUSER hive. It can be found in the following location:  \n\n\n=== Page 22 ===\n\nNTUSER.DAT \\Software \\Microsoft \\Office \\VERSION  \nThe version number for each Microsoft Office release is different. An \nexample registry key will look like this:  \nNTUSER.DAT \\Software \\Microsoft \\Office \\15.0 \\Word  \nHere, the 15.0 refers to Office 2013. A list of different Office releases and \ntheir version numbers can be found on this link . \nStarting from Office 365, Microsoft now ties the location to the user's \nlive ID . In such a scenario, the recent files can be found at the following \nlocation.   \nNTUSER.DAT \\Software \\Microsoft \\Office \\VERSION \\UserMRU \\LiveID_###\n#\\FileMRU  \nIn such a scenario, the recent files can be found at the following location. \nThis location also saves the complete path of the most recently used \nfiles.  \n \nUserAssist :  \nWindows keeps track of applications launched by the user using \nWindows Explorer for statistical purposes in the User Assist registry keys. \nThese keys contain information about the programs launched, the time \nof their launch, and the number of times they we re executed. However, \nprograms that were run using the command line can't be found in the \nUser Assist keys. The User Assist key is present in the NTUSER hive, \nmapped to each user's GUID. We can find it at the following location:  \nNTUSER.DAT \\Software \\Microsoft \\Windows \\Currentversion \\Explorer \\Us\nerAssist \\{GUID} \\Count  \nTake a look at the below screenshot from Registry Explorer and answer \nQuestion #1.  \n \n\n\n=== Page 23 ===\n\nShimCache:  \nShimCache is a mechanism used to keep track of application \ncompatibility with the OS and tracks all applications launched on the \nmachine. Its main purpose in Windows is to ensure backward \ncompatibility of applications. It is also called Application Compati bility \nCache (AppCompatCache). It is located in the following location in the \nSYSTEM hive:  \nSYSTEM \\CurrentControlSet \\Control \\Session Manager \\AppCompatCache  \nShimCache stores file name, file size, and last modified time of the \nexecutables.  \nOur goto tool, the Registry Explorer, doesn't parse ShimCache data in a \nhuman -readable format, so we go to another tool called \nAppCompatCache Parser, also a part of Eric Zimmerman's tools. It takes \nthe SYSTEM hive as input, parses the data, and outputs a C SV file that \nlooks like this:  \n \nWe can use the following command to run the AppCompatCache Parser \nUtility:  \nAppCompatCacheParser.exe --csv <path to save output> -f <path to \nSYSTEM hive for data parsing> -c <control set to parse>  \nThe output can be viewed using EZviewer, another one of Eric \nZimmerman's tools.  \nAmCache:  \nThe AmCache hive is an artifact related to ShimCache. This performs a \nsimilar function to ShimCache, and stores additional data related to \nprogram executions. This data includes execution path, installation, \nexecution and deletion times, and SHA1 hashes of  the executed \nprograms. This hive is located in the file system at:  \nC:\\Windows \\appcompat \\Programs \\Amcache.hve  \n\n\n=== Page 24 ===\n\nInformation about the last executed programs can be found at the \nfollowing location in the hive:  \nAmcache.hve \\Root \\File\\{Volume GUID} \\  \nThis is how Registry Explorer parses the AmCache hive:  \n \n  \nBAM/DAM:  \nBackground Activity Monitor or BAM keeps a tab on the activity of \nbackground applications. Similar Desktop Activity Moderator or DAM is a \npart of Microsoft Windows that optimizes the power consumption of the \ndevice. Both of these are a part of the Modern S tandby system in \nMicrosoft Windows.  \nIn the Windows registry, the following locations contain information \nrelated to BAM and DAM. This location contains information about last \nrun programs, their full paths, and last execution time.  \nSYSTEM \\CurrentControlSet \\Services \\bam \\UserSettings \\{SID}  \nSYSTEM \\CurrentControlSet \\Services \\dam \\UserSettings \\{SID}  \nBelow you can see how Registry Explorer parses data from BAM:  \n \n \n\n\n=== Page 25 ===\n\nAnswer the questions below  \n \nHow many times was the File Explorer launched?  \nWhich of the artifacts also saves SHA1 hashes of the executed programs?  \nWhich of the artifacts saves the full path of the executed programs?  \nWhat is the Absolute Path of the file opened using notepad.exe?  \nWhen was this file opened?  \n  \n\n=== Page 26 ===\n\n- External Devices/USB device forensics  \n \nWhen performing forensics on a machine, often the need arises to \nidentify if any USB or removable drives were attached to the machine. If \nso, any information related to those devices is important for a forensic \ninvestigator. In this task, we will go throug h the different ways to find \ninformation on connected devices and the drives on a system using the \nregistry.  \nDevice identification:  \nThe following locations keep track of USB keys plugged into a system. \nThese locations store the vendor id, product id, and version of the USB \ndevice plugged in and can be used to identify unique devices. These \nlocations also store the time the devices were  plugged into the system.  \nSYSTEM \\CurrentControlSet \\Enum \\USBSTOR  \nSYSTEM \\CurrentControlSet \\Enum \\USB  \nRegistry Explorer shows this information in a nice and easy -to-\nunderstand way. Take a look at this and answer Questions # 1 and 2.  \n \n  \nFirst/Last Times:  \nSimilarly, the following registry key tracks the first time the device was \nconnected, the last time it was connected and the last time the device \nwas removed from the system.  \nSYSTEM \\CurrentControlSet \\Enum \\USBSTOR \\Ven_Prod_Version \\USBSeri\nal#\\Properties \\{83da6326 -97a6 -4088 -9453 -a19231573b29} \\####  \nIn this key, the #### sign can be replaced by the following digits to get \nthe required information:  \nValue  Information  \n\n\n=== Page 27 ===\n\n0064  First Connection time  \n0066  Last Connection time  \n0067  Last removal time  \nAlthough we can check this value manually, as we have seen above, \nRegistry Explorer already parses this data and shows us if we select the \nUSBSTOR key.  \nUSB device Volume Name:  \nThe device name of the connected drive can be found at the following \nlocation:  \nSOFTWARE \\Microsoft \\Windows Portable Devices \\Devices  \n  \nWe can compare the GUID we see here in this registry key and compare \nit with the Disk ID we see on keys mentioned in device identification to \ncorrelate the names with unique devices. Take a look at these two \nscreenshots and answer Question # 3.  \nCombining all of this information, we can create a fair picture of any USB \ndevices that were connected to the machine we're investigating.   \n \nAnswer the questions below  \nWhat is the serial number of the device from the manufacturer \n'Kingston'?  \n \nWhat is the name of this device?  \n \nWhat is the friendly name of the device from the manufacturer \n'Kingston'?  \n \n"
}